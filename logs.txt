[useSelectionState] Product dimensions: 
Object { id: "product-1761381781978-0.8693799526071119", productType: "fan", scaleFactor: 239.52396803179232, realWorldSize: 1.4, realWorldWidth: undefined, realWorldHeight: undefined, configWidth: 40, configHeight: 40, scaleX: 1, scaleY: 1, … }
​
configHeight: 40
​
configWidth: 40
​
finalHeight: 335.3335552445092
​
finalWidth: 335.3335552445092
​
id: "product-1761381781978-0.8693799526071119"
​
productType: "fan"
​
realWorldHeight: undefined
​
realWorldSize: 1.4
​
realWorldWidth: undefined
​
scaleFactor: 239.52396803179232
​
scaleX: 1
​
scaleY: 1
​
<prototype>: Object { … }
useSelectionState.js:85:17
[useSelectionState] Item bounds: 
Object { id: "product-1761381781978-0.8693799526071119", x: 113.17319616863988, y: -412.5058136955889, width: 335.3335552445092, height: 335.3335552445092, bounds: {…} }
​
bounds: Object { minX: -54.49358145361474, maxX: 280.8399737908945, minY: -580.1725913178435, … }
​​
maxX: 280.8399737908945
​​
maxY: -244.8390360733343
​​
minX: -54.49358145361474
​​
minY: -580.1725913178435
​​
<prototype>: Object { … }
​
height: 335.3335552445092
​
id: "product-1761381781978-0.8693799526071119"
​
width: 335.3335552445092
​
x: 113.17319616863988
​
y: -412.5058136955889
​
<prototype>: Object { … }
useSelectionState.js:108:15
[useSelectionState] Final bounding box: 
Object { minX: -54.49358145361474, maxX: 280.8399737908945, minY: -580.1725913178435, maxY: -244.8390360733343, centerX: 113.17319616863986, centerY: -412.5058136955889, width: 335.3335552445092, height: 335.33355524450917, itemCount: 1 }
useSelectionState.js:129:13
[SelectionState] Selected product positions: 
Array [ {…} ]
​
0: Object { id: "product-1761381781978-0.8693799526071119", x: 113.17319616863988, y: -412.5058136955889 }
​
length: 1
​
<prototype>: Array []
useSelectionState.js:155:13
[SelectionState] Selected text positions: 
Array []
useSelectionState.js:156:13
[SelectionState] Bounding box: 
Object { minX: -54.49358145361474, minY: -580.1725913178435, maxX: 280.8399737908945, maxY: -244.8390360733343, centerX: 113.17319616863986, centerY: -412.5058136955889 }
useSelectionState.js:157:13
[ProductShape:selected] 
Object { id: "product-1761381781978-0.8693799526071119", x: 1.4210854715202004e-14, y: 0, rotation: 0, isSelected: true, groupX: 113.17319616863986, groupY: -412.5058136955889 }
ProductsLayer.jsx:195:23
[ProductShape:render] 
Object { id: "product-1761381781978-0.8693799526071119", x: 1.4210854715202004e-14, y: 0, rotation: 0, scaleX: 1, scaleY: 1, renderedWidth: 335.3335552445092, renderedHeight: 335.3335552445092, rectBounds: {…}, draggable: false, … }
​
customStroke: "#1976d2"
​
draggable: false
​
fill: "#B2EBF2"
​
id: "product-1761381781978-0.8693799526071119"
​
listening: true
​
opacity: 1
​
rectBounds: Object { x: -167.6667776222546, y: -167.6667776222546, width: 335.3335552445092, … }
​​
height: 335.3335552445092
​​
width: 335.3335552445092
​​
x: -167.6667776222546
​​
y: -167.6667776222546
​​
<prototype>: Object { … }
​
renderedHeight: 335.3335552445092
​
renderedWidth: 335.3335552445092
​
rotation: 0
​
scaleX: 1
​
scaleY: 1
​
x: 1.4210854715202004e-14
​
y: 0
​
<prototype>: Object { … }
ProductShape.jsx:41:13
[useEffect transformer] Attaching transformer 
Object { selectedCount: 1, currentRotation: 0, groupX: 113.17319616863986, groupY: -412.5058136955889, centerX: 113.17319616863986, centerY: -412.5058136955889, snapshotWidth: 335.3335552445092, snapshotHeight: 335.33355524450917 }
useSelectionState.js:199:15
[useEffect transformer] Group client rect: 
Object { x: 867.933246971948, y: 175.34700022448772, width: 124.51642241581692, height: 124.51642241581698 }
useSelectionState.js:224:15
[useEffect transformer] Transformer client rect: 
Object { x: 863.433246971948, y: 120.84700022448772, width: 133.14620534864002, height: 183.14620534864002 }
useSelectionState.js:228:15
[useEffect transformer] Transformer and Group event handlers: 
Object { hasGroupOnTransformEnd: "undefined", hasGroupOnDragEnd: "undefined" }
useSelectionState.js:233:15
[ProductShapes.fan] 
Object { width: 335.3335552445092, radius: 167.6667776222546 }
productShapes.js:117:13
[ProductShapes.fan] 
Object { width: 335.3335552445092, radius: 167.6667776222546 }
productShapes.js:117:13


HTML5 Canvas Shape select, resize and rotate

Transformer is a special kind of Konva.Group. It allows you easily resize and rotate any node or set of nodes.

To enable it you need to:

    Create new instance with new Konva.Transformer()
    Add it to layer
    attach to node with transformer.nodes([shape]);

Note: Transforming tool is not changing width and height properties of nodes when you resize them. Instead it changes scaleX and scaleY properties.

Instructions: Try to resize and rotate shapes. Click on empty area to remove selection. Use SHIFT or CTRL to add/remove shapes into/from selection. Try to select area on a canvas.

import { Stage, Layer, Rect, Transformer } from 'react-konva';
import { useState, useEffect, useRef } from 'react';

const initialRectangles = [
  {
    x: 60,
    y: 60,
    width: 100,
    height: 90,
    fill: 'red',
    id: 'rect1',
    name: 'rect',
    rotation: 0,
  },
  {
    x: 250,
    y: 100,
    width: 150,
    height: 90,
    fill: 'green',
    id: 'rect2',
    name: 'rect',
    rotation: 0,
  },
];

// Helper functions for calculating bounding boxes of rotated rectangles
const degToRad = (angle) => (angle / 180) * Math.PI;

const getCorner = (pivotX, pivotY, diffX, diffY, angle) => {
  const distance = Math.sqrt(diffX * diffX + diffY * diffY);
  angle += Math.atan2(diffY, diffX);
  const x = pivotX + distance * Math.cos(angle);
  const y = pivotY + distance * Math.sin(angle);
  return { x, y };
};

const getClientRect = (element) => {
  const { x, y, width, height, rotation = 0 } = element;
  const rad = degToRad(rotation);

  const p1 = getCorner(x, y, 0, 0, rad);
  const p2 = getCorner(x, y, width, 0, rad);
  const p3 = getCorner(x, y, width, height, rad);
  const p4 = getCorner(x, y, 0, height, rad);

  const minX = Math.min(p1.x, p2.x, p3.x, p4.x);
  const minY = Math.min(p1.y, p2.y, p3.y, p4.y);
  const maxX = Math.max(p1.x, p2.x, p3.x, p4.x);
  const maxY = Math.max(p1.y, p2.y, p3.y, p4.y);

  return {
    x: minX,
    y: minY,
    width: maxX - minX,
    height: maxY - minY,
  };
};

const App = () => {
  const [rectangles, setRectangles] = useState(initialRectangles);
  const [selectedIds, setSelectedIds] = useState([]);
  const [selectionRectangle, setSelectionRectangle] = useState({
    visible: false,
    x1: 0,
    y1: 0,
    x2: 0,
    y2: 0,
  });
  
  const isSelecting = useRef(false);
  const transformerRef = useRef();
  const rectRefs = useRef(new Map());
  
  // Update transformer when selection changes
  useEffect(() => {
    if (selectedIds.length && transformerRef.current) {
      // Get the nodes from the refs Map
      const nodes = selectedIds
        .map(id => rectRefs.current.get(id))
        .filter(node => node);
      
      transformerRef.current.nodes(nodes);
    } else if (transformerRef.current) {
      // Clear selection
      transformerRef.current.nodes([]);
    }
  }, [selectedIds]);
  
  // Click handler for stage
  const handleStageClick = (e) => {
    // If we are selecting with rect, do nothing
    if (selectionRectangle.visible) {
      return;
    }

    // If click on empty area - remove all selections
    if (e.target === e.target.getStage()) {
      setSelectedIds([]);
      return;
    }

    // Do nothing if clicked NOT on our rectangles
    if (!e.target.hasName('rect')) {
      return;
    }

    const clickedId = e.target.id();
    
    // Do we pressed shift or ctrl?
    const metaPressed = e.evt.shiftKey || e.evt.ctrlKey || e.evt.metaKey;
    const isSelected = selectedIds.includes(clickedId);

    if (!metaPressed && !isSelected) {
      // If no key pressed and the node is not selected
      // select just one
      setSelectedIds([clickedId]);
    } else if (metaPressed && isSelected) {
      // If we pressed keys and node was selected
      // we need to remove it from selection
      setSelectedIds(selectedIds.filter(id => id !== clickedId));
    } else if (metaPressed && !isSelected) {
      // Add the node into selection
      setSelectedIds([...selectedIds, clickedId]);
    }
  };
  
  const handleMouseDown = (e) => {
    // Do nothing if we mousedown on any shape
    if (e.target !== e.target.getStage()) {
      return;
    }
    
    // Start selection rectangle
    isSelecting.current = true;
    const pos = e.target.getStage().getPointerPosition();
    setSelectionRectangle({
      visible: true,
      x1: pos.x,
      y1: pos.y,
      x2: pos.x,
      y2: pos.y,
    });
  };

  const handleMouseMove = (e) => {
    // Do nothing if we didn't start selection
    if (!isSelecting.current) {
      return;
    }
    
    const pos = e.target.getStage().getPointerPosition();
    setSelectionRectangle({
      ...selectionRectangle,
      x2: pos.x,
      y2: pos.y,
    });
  };

  const handleMouseUp = () => {
    // Do nothing if we didn't start selection
    if (!isSelecting.current) {
      return;
    }
    isSelecting.current = false;
    
    // Update visibility in timeout, so we can check it in click event
    setTimeout(() => {
      setSelectionRectangle({
        ...selectionRectangle,
        visible: false,
      });
    });

    const selBox = {
      x: Math.min(selectionRectangle.x1, selectionRectangle.x2),
      y: Math.min(selectionRectangle.y1, selectionRectangle.y2),
      width: Math.abs(selectionRectangle.x2 - selectionRectangle.x1),
      height: Math.abs(selectionRectangle.y2 - selectionRectangle.y1),
    };

    const selected = rectangles.filter(rect => {
      // Check if rectangle intersects with selection box
      return Konva.Util.haveIntersection(selBox, getClientRect(rect));
    });
    
    setSelectedIds(selected.map(rect => rect.id));
  };

  const handleDragEnd = (e) => {
    const id = e.target.id();
    setRectangles(prevRects => {
      const newRects = [...prevRects];
      const index = newRects.findIndex(r => r.id === id);
      if (index !== -1) {
        newRects[index] = {
          ...newRects[index],
          x: e.target.x(),
          y: e.target.y()
        };
      }
      return newRects;
    });
  };

  const handleTransformEnd = (e) => {
    // Find which rectangle(s) were transformed
    const id = e.target.id();
    const node = e.target;
    
    setRectangles(prevRects => {
      const newRects = [...prevRects];
      
      // Update each transformed node
      const index = newRects.findIndex(r => r.id === id);
      
      if (index !== -1) {
        const scaleX = node.scaleX();
        const scaleY = node.scaleY();
        
        // Reset scale
        node.scaleX(1);
        node.scaleY(1);
        
        // Update the state with new values
        newRects[index] = {
          ...newRects[index],
          x: node.x(),
          y: node.y(),
          width: Math.max(5, node.width() * scaleX),
          height: Math.max(node.height() * scaleY),
          rotation: node.rotation(),
        };
      }
      
      return newRects;
    });
  };

  return (
    <Stage
      width={window.innerWidth}
      height={window.innerHeight}
      onMouseDown={handleMouseDown}
      onMousemove={handleMouseMove}
      onMouseup={handleMouseUp}
      onClick={handleStageClick}
    >
      <Layer>
        {/* Render rectangles directly */}
        {rectangles.map(rect => (
          <Rect
            key={rect.id}
            id={rect.id}
            x={rect.x}
            y={rect.y}
            width={rect.width}
            height={rect.height}
            fill={rect.fill}
            name={rect.name}
            rotation={rect.rotation}
            draggable
            ref={node => {
              if (node) {
                rectRefs.current.set(rect.id, node);
              }
            }}
            onDragEnd={handleDragEnd}
            onTransformEnd={handleTransformEnd}
          />
        ))}
        
        {/* Single transformer for all selected shapes */}
        <Transformer
          ref={transformerRef}
          boundBoxFunc={(oldBox, newBox) => {
            // Limit resize
            if (newBox.width < 5 || newBox.height < 5) {
              return oldBox;
            }
            return newBox;
          }}
          
        />
        
        {/* Selection rectangle */}
        {selectionRectangle.visible && (
          <Rect
            x={Math.min(selectionRectangle.x1, selectionRectangle.x2)}
            y={Math.min(selectionRectangle.y1, selectionRectangle.y2)}
            width={Math.abs(selectionRectangle.x2 - selectionRectangle.x1)}
            height={Math.abs(selectionRectangle.y2 - selectionRectangle.y1)}
            fill="rgba(0,0,255,0.5)"
          />
        )}
      </Layer>
    </Stage>
  );
};

export default App;
